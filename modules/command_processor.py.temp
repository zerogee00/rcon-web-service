"""
Command processing and RCON execution module
"""
import subprocess
import logging
import re
from config.settings import (SERVERS, CONFIG, ALIASES, LUCKPERMS_SHORTCUTS, 
                           ESSENTIALS_SHORTCUTS, COMMAND_DESCRIPTIONS)
from utils.server_utils import clean_output_text, get_server_info
from utils.context_manager import get_user_context, set_user_context, clear_user_context

logger = logging.getLogger(__name__)

def execute_rcon_command(server_id, command, source="Web Service"):
    """Execute RCON command on specified server"""
    if server_id not in SERVERS:
        return f"‚ùå Invalid server ID: {server_id}"
    
    server_config = SERVERS[server_id]
    server_info = get_server_info(server_id)
    
    logger.info(f"Executing RCON command on {server_info['name']} ({server_id}): {command} [Source: {source}]")
    
    try:
        result = subprocess.run([
            'mcrcon', '-H', 'localhost', '-P', str(server_config['port']), 
            '-p', server_config['password'], command
        ], capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            output = clean_output_text(result.stdout)
            if not output.strip():
                output = "‚úÖ Command executed successfully (no output)"
            logger.info(f"RCON command successful on {server_id}")
            return output
        else:
            error_msg = clean_output_text(result.stderr) or "Unknown error occurred"
            logger.error(f"RCON command failed on {server_id}: {error_msg}")
            return f"‚ùå Command failed: {error_msg}"
            
    except subprocess.TimeoutExpired:
        logger.error(f"RCON command timeout on {server_id}")
        return "‚ùå Command timed out after 30 seconds"
    except FileNotFoundError:
        logger.error("mcrcon not found")
        return "‚ùå RCON client not available on server"
    except Exception as e:
        logger.error(f"Unexpected error executing RCON command: {str(e)}")
        return f"‚ùå Unexpected error: {str(e)}"

def format_command_template(template, args):
    """Format command template with provided arguments"""
    try:
        # Simple placeholder replacement
        placeholders = re.findall(r'\{(\w+)\}', template)
        formatted_command = template
        
        for i, placeholder in enumerate(placeholders):
            if i < len(args):
                formatted_command = formatted_command.replace(f'{{{placeholder}}}', args[i])
            else:
                return None, f"Missing argument for {{{placeholder}}}"
        
        # Check if there are unused arguments
        remaining_placeholders = re.findall(r'\{(\w+)\}', formatted_command)
        if remaining_placeholders:
            return None, f"Missing arguments: {', '.join(['{' + p + '}' for p in remaining_placeholders])}"
        
        return formatted_command, None
    except Exception as e:
        return None, f"Error formatting command: {str(e)}"

def process_command_alias(command, user_name="unknown"):
    """Process command aliases and shortcuts"""
    if not command.strip():
        return command, None
    
    parts = command.strip().split()
    base_command = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    # Check regular aliases first
    if CONFIG.get('enable_aliases', True) and base_command in ALIASES:
        template = ALIASES[base_command]
        if '{' in template:
            formatted_command, error = format_command_template(template, args)
            if error:
                return command, f"Alias error: {error}"
            return formatted_command, None
        else:
            # Simple alias without parameters
            return template + (' ' + ' '.join(args) if args else ''), None
    
    # Check LuckPerms shortcuts
    if CONFIG.get('enable_luckperms_shortcuts', True) and base_command in LUCKPERMS_SHORTCUTS:
        template = LUCKPERMS_SHORTCUTS[base_command]
        formatted_command, error = format_command_template(template, args)
        if error:
            return command, f"LuckPerms shortcut error: {error}"
        return formatted_command, None
    
    # Check Essentials shortcuts
    if CONFIG.get('enable_essentials_shortcuts', True) and base_command in ESSENTIALS_SHORTCUTS:
        template = ESSENTIALS_SHORTCUTS[base_command]
        if '{' in template:
            formatted_command, error = format_command_template(template, args)
            if error:
                return command, f"Essentials shortcut error: {error}"
            return formatted_command, None
        else:
            return template + (' ' + ' '.join(args) if args else ''), None
    
    return command, None

def execute_context_command(command, user_name):
    """Execute a command within user's current context"""
    context = get_user_context(user_name)
    if not context:
        return "‚ùå No active context. Please start a new command session."
    
    if context['type'] == 'server_selection':
        # User is selecting a server
        try:
            choice = int(command.strip())
            available_servers = context['data']['servers']
            
            if 1 <= choice <= len(available_servers):
                selected_server = available_servers[choice - 1]
                pending_command = context['data']['command']
                
                # Clear context
                clear_user_context(user_name)
                
                # Execute the pending command on selected server
                processed_command, error = process_command_alias(pending_command, user_name)
                if error:
                    return f"‚ùå {error}"
                
                result = execute_rcon_command(selected_server, processed_command, f"Slack User: {user_name}")
                return f"**Server: {get_server_info(selected_server)['name']}**\n```\n{result}\n```"
            else:
                return f"‚ùå Invalid choice. Please enter a number between 1 and {len(available_servers)}, or 'cancel' to abort."
                
        except ValueError:
            if command.strip().lower() == 'cancel':
                clear_user_context(user_name)
                return "‚úÖ Command cancelled."
            return "‚ùå Please enter a valid number or 'cancel' to abort."
    
    elif context['type'] == 'config_edit':
        # Handle configuration editing context
        return handle_config_context(command, user_name, context)
    
    return "‚ùå Unknown context type."

def handle_config_context(command, user_name, context):
    """Handle configuration editing context"""
    # This would be implemented based on your config editing needs
    # For now, just clear context
    clear_user_context(user_name)
    return "‚úÖ Configuration context cleared."

def execute_config_command(command, user_name):
    """Execute configuration management commands"""
    if not user_name:
        return "‚ùå User authentication required."
    
    parts = command.strip().split()
    if len(parts) < 2:
        return """üîß **Configuration Commands**
        
Available commands:
‚Ä¢ `config get <key>` - Get configuration value
‚Ä¢ `config set <key> <value>` - Set configuration value
‚Ä¢ `config list` - List all configuration keys
‚Ä¢ `config reset <key>` - Reset to default value

**Examples:**
‚Ä¢ `config get enable_aliases`
‚Ä¢ `config set max_command_length 600`
‚Ä¢ `config list`"""
    
    subcommand = parts[1].lower()
    
    if subcommand == 'get':
        if len(parts) < 3:
            return "‚ùå Usage: config get <key>"
        key = parts[2]
        value = CONFIG.get(key, "Key not found")
        return f"**{key}**: `{value}`"
    
    elif subcommand == 'set':
        if len(parts) < 4:
            return "‚ùå Usage: config set <key> <value>"
        key = parts[2]
        value = ' '.join(parts[3:])
        
        # Type conversion
        if value.lower() in ['true', 'false']:
            value = value.lower() == 'true'
        elif value.isdigit():
            value = int(value)
        
        CONFIG[key] = value
        return f"‚úÖ Set **{key}** to `{value}`"
    
    elif subcommand == 'list':
        config_list = "\n".join([f"‚Ä¢ **{k}**: `{v}`" for k, v in CONFIG.items()])
        return f"üìã **Current Configuration:**\n\n{config_list}"
    
    elif subcommand == 'reset':
        if len(parts) < 3:
            return "‚ùå Usage: config reset <key>"
        # This would reset to defaults - implementation depends on your needs
        return f"‚úÖ Configuration key {parts[2]} reset to default"
    
    else:
        return f"‚ùå Unknown config command: {subcommand}"

def convert_to_essentials_command(command, source="Web Service"):
    """Convert standard commands to Essentials format if needed"""
    if not CONFIG.get('enable_essentials_shortcuts', True):
        return command
    
    # Add Essentials prefix for certain commands if not already present
    essentials_commands = ['home', 'sethome', 'spawn', 'setspawn', 'warp', 'setwarp', 
                          'delwarp', 'tpaccept', 'tpdeny', 'tphere', 'back', 'msg', 'r', 'broadcast']
    
    parts = command.strip().split()
    if parts and parts[0].lower() in essentials_commands and not parts[0].startswith('/'):
        return '/' + command
    
    return command

def get_command_description(command):
    """Get description for a command"""
    base_command = command.split()[0].lower() if command else ""
    return COMMAND_DESCRIPTIONS.get(base_command, "No description available")

def validate_command_safety(command, user_name):
    """Validate command safety and permissions"""
    dangerous_commands = ['stop', 'restart', '/stop', '/restart', 'kill']
    
    if not CONFIG.get('enable_dangerous_commands', False):
        for dangerous in dangerous_commands:
            if dangerous in command.lower():
                from utils.security import is_admin_user
                if not is_admin_user(user_name):
                    return False, f"‚ùå Dangerous command '{dangerous}' is restricted to admin users."
    
    if len(command) > CONFIG.get('max_command_length', 500):
        return False, f"‚ùå Command too long (max {CONFIG.get('max_command_length', 500)} characters)."
    
    return True, None

def parse_coordinates(coordinates_output):
    """Parse coordinates from player data query output"""
    try:
        # Look for coordinate patterns like "Pos: [-123.45, 64.0, 789.12]"
        pos_match = re.search(r'Pos:\s*\[([^]]+)\]', coordinates_output)
        if pos_match:
            coords_str = pos_match.group(1)
            coords = [float(x.strip()) for x in coords_str.split(',')]
            if len(coords) >= 3:
                # Convert to integers (whole block coordinates)
                x = int(coords[0])
                y = int(coords[1])
                z = int(coords[2])
                return x, y, z, None
        
        # Alternative pattern for different output formats
        xyz_match = re.search(r'(-?\d+\.?\d*),?\s+(-?\d+\.?\d*),?\s+(-?\d+\.?\d*)', coordinates_output)
        if xyz_match:
            x = int(float(xyz_match.group(1)))
            y = int(float(xyz_match.group(2)))
            z = int(float(xyz_match.group(3)))
            return x, y, z, None
            
        return None, None, None, "Could not parse coordinates from output"
        
    except Exception as e:
        return None, None, None, f"Error parsing coordinates: {str(e)}"

def execute_coordinate_command(server_id, player_name, command_template, source="Web Service"):
    """Execute a command using a player's current coordinates
    
    Args:
        server_id: The server to execute on
        player_name: The player whose coordinates to get
        command_template: Command template with {x}, {y}, {z} placeholders
        source: Command source for logging
        
    Returns:
        Command execution result
    """
    try:
        # First, get the player's coordinates
        coord_command = f"data get entity {player_name} Pos"
        logger.info(f"Getting coordinates for {player_name} on {server_id}")
        
        coord_result = execute_rcon_command(server_id, coord_command, source)
        
        if coord_result.startswith("‚ùå"):
            return coord_result
        
        # Parse the coordinates
        x, y, z, error = parse_coordinates(coord_result)
        if error:
            return f"‚ùå {error}. Raw output: {coord_result}"
        
        # Format the command template with coordinates
        final_command = command_template.format(x=x, y=y, z=z, player=player_name)
        
        logger.info(f"Executing coordinate-based command: {final_command}")
        
        # Execute the final command
        result = execute_rcon_command(server_id, final_command, source)
        
        # Return both coordinate info and command result
        return f"üéØ **Coordinates for {player_name}**: {x}, {y}, {z}\nüìù **Command**: `{final_command}`\nüì§ **Result**:\n{result}"
        
    except Exception as e:
        logger.error(f"Error in coordinate command execution: {str(e)}")
        return f"‚ùå Error executing coordinate command: {str(e)}"

def process_coordinate_alias(command, user_name="unknown"):
    """Process coordinate-based command aliases
    
    Expected format: coordcmd <player> <server_id> <command_template>
    Example: coordcmd Steve survival setblock {x} {y} {z} minecraft:oak_hanging_sign
    """
    parts = command.strip().split()
    
    if len(parts) < 4:
        return None, """‚ùå **Coordinate Command Usage:**
        
`coordcmd <player> <server_id> <command_template>`

**Available placeholders in command_template:**
‚Ä¢ `{x}` - Player's X coordinate (integer)
‚Ä¢ `{y}` - Player's Y coordinate (integer) 
‚Ä¢ `{z}` - Player's Z coordinate (integer)
‚Ä¢ `{player}` - Player's name

**Examples:**
‚Ä¢ `coordcmd Steve survival setblock {x} {y} {z} minecraft:oak_hanging_sign`
‚Ä¢ `coordcmd Alice creative fill {x} {y} {z} {x} {y} {z} minecraft:diamond_block`
‚Ä¢ `coordcmd Bob skyblock tp {player} {x} {y} {z}`
‚Ä¢ `coordcmd Steve survival summon minecraft:villager {x} {y} {z}`

**Note:** Coordinates are automatically converted to integers (whole blocks)."""
    
    player_name = parts[1]
    server_id = parts[2]
    command_template = ' '.join(parts[3:])
    
    # Validate server exists
    if server_id not in SERVERS:
        available_servers = ', '.join(SERVERS.keys())
        return None, f"‚ùå Invalid server ID: {server_id}. Available servers: {available_servers}"
    
    # Execute the coordinate command
    result = execute_coordinate_command(server_id, player_name, command_template, f"Slack User: {user_name}")
    return result, None
